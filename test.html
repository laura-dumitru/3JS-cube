//For designers
let options = {
    gameTime: 20, // how many seconds is it running for?
    scoreIncrement: 10, // how many points per pair found?
    maxScore: this.scoreIncrement * 4, // the maximum score for this game is 40 points. 
}
//Please do not change any code below this line. 
let opts = {
   scoreTotal: 0,
   interval: 0,
   scoreTexty: unit.find('score'),
   countdown: screen.find('countdown'),
   endCard: unit.find('EndCard'),
   cards: screen.findByType('Flippy'),
   
   reset: function() {
        
        logger('reset game');
        this.cards.forEach(function (card) {
            card.node.style.pointerEvents = 'all'; //card.getNode().style
            card.resetAction(ctx, {}, noop);
        });
        tempArr = [];
        pairsFound = 0;
        //this.countdown.node.innerText = 0;
       // this.scoreTexty.node.innerText = 'SCORE: 0';
        clearInterval(opts.interval);
        this.gameTime = 10;
        this.scoreTotal = 0;
        //if the scoreTotal is not reset to zero, the game only lets you play up until you reach 40points.
        flag = false; 
        //console.log(this.gameTime);
         start = unit.find('Start');
         unit.goToScreenAction(ctx, { screen: start, animation: { animation: 'fade', duration: 1000, } }, noop);
         this.countdown.setTextAction(ctx, { text: this.gameTime }, noop)
         this.scoreTexty.setTextAction(ctx, { text: 'SCORE: 0' }, noop)
    },
    
    score: function() {
      this.scoreTexty.setTextAction(ctx, { text: `SCORE: ${this.scoreTotal += options.scoreIncrement }` }, noop)

        console.log('scoreTotal')
    },
    
    countdownStart: function() {
        
        opts.interval = setInterval(function () {
            options.gameTime --;
            
        if (opts.scoreTotal >= options.maxScore ||  options.gameTime <= 0) { // || opts.gameTime <= 0 //if timer runs out or they got all pairs
            clearInterval(opts.interval)
            unit.goToScreenAction(ctx, { screen: opts.endCard, animation: { animation: 'fade', duration: 1000 } }, noop);

            }

       opts.countdown.setTextAction(ctx, { text:  options.gameTime }, noop)
    
        }, 1000); //delay
    }
};

unit.opts = opts;
unit.options = options;

let actionCtx = ctx, flags = [], destinationScreen = unit.find('EndCard'), pairs, pairsFound = 0, lockBoard = false, flag = false, interval;

screen.once('appeared', (function () {
    actionCtx = new ActionContext(this, {
        'certainlyNotCausedByUserBehavior': false,
        'consideredUserInitiatedByBrowser': false
    });
    init();
}).bind(this));


//Check if all cards are fipped and then go to end card
function checkAll() {
    //logger('here --------', pairsFound, screen.cards.length / 2)
    if(pairsFound === opts.cards.length / 2 ) {
        logger('FOUND THEM ALL');
        if (opts.endCard){
            //goto endcard
            unit.goToScreenAction(ctx, { screen: opts.endCard, animation: { animation: 'fade', duration: 1000 } }, noop);
        }
        else {
            //reset screen
        }
        // screen.reset.showAction(ctx, {}, noop) // unit.goToScreenAction(ctx, { screen: destinationScreen }, noop)
    }
    else {
        logger('more to find');
    }
}

//Util Timeout promise
const delay = t => new Promise(resolve => setTimeout(resolve, t));

// use this to go to end card - unit.goToScreenAction(ctx, { screen: opts.endCard, animation: { animation: 'fade', duration: 1000 } }, noop);
function init() {
    console.log("INIT")
    // returns an array of all Flippy objects
    opts.cards.forEach(function (card) {
        tempArr = [];
        // logger(card);
        // Add eventlistener to each card in the array
        card.node.addEventListener('click', () => {
            //Only run countdown on first click
            if (!flag) {
                opts.countdownStart();
                flag = true;
            }

            engagementChecker();
            
            mediator(`Card_${card.reverseContent.objects[0].name}_clicked`);

            if (lockBoard) return;

            // if(tempArr.length === 2) tempArr = [];

            //flip the card
            card.flipToBack('east', 400, noop);
            //remove pointer events so it cannot be flipped again
            //card.node.style.pointerEvents = 'none';
            //push selected cards to temp array
            if (!tempArr.includes(card)) tempArr.push(card); // card.reverseContent.objects[0].name

            if (tempArr.length === 2) {
                lockBoard = true;
                if (tempArr.length > 1) {
                    if (tempArr[0].reverseContent.objects[0].name !== tempArr[1].reverseContent.objects[0].name || tempArr[0].localId === tempArr[1].localId) {
                        delay(1000).then(() => {
                            logger('no match, flip cards back');
                            //flip the last 2 selected back
                            // logger('cards: ', tempArr[0], tempArr[1]);
                        }).then(() => {
                            tempArr.forEach(function (c) {
                                c.flipToFront('west', 400, noop);
                            });
                        }).then(() => {
                            //clear card arr
                            tempArr = [];
                            lockBoard = false;
                        });
                    }
                    else if (tempArr[0].localId !== tempArr[1].localId && tempArr[0].reverseContent.objects[0].name === tempArr[1].reverseContent.objects[0].name) {
                        delay(1000).then(() => {
                            // if they match do noting clear array and remove pointer events
                            //TODO remove pointer events
                            logger('found a match', `${tempArr[0]} and  ${tempArr[1]}`);
                            tempArr[0].node.style.pointerEvents = 'none';
                            tempArr[1].node.style.pointerEvents = 'none';
                            unit.opts.score(); 
                        }).then(() => {
                            tempArr = [];
                            pairsFound += 1;
                        }).then(() => {
                            checkAll();
                            lockBoard = false;
                        });
                    }
                }

            }
        });
    });
}

//Check and fires custom engement
function engagementChecker() {
    !creative.getUserInteracted() ? (actionCtx.trackUserInteraction(), console.debug('custom engagement fired')) : console.debug('already engaged');
}

//Event dispatcher
function mediator(event_name) {
    if (!flags.includes(event_name)) {
        Creative.trackCustomEventAction(actionCtx, { name: event_name }, function () {
            flags.push(event_name);
            console.debug('mediator', event_name);
            console.debug(flags);
        });
    }
}

//Custom console debug logger
function logger() {
    if (window.location.href.indexOf("celtra") != -1) {
        let date = new Date();
        let now =
            date.getFullYear() +
            "-" +
            (date.getMonth() + 1) +
            "-" +
            date.getDate() +
            " " +
            date.getHours() +
            ":" +
            date.getMinutes() +
            ":" +
            date.getSeconds();
        console.debug(
            "%c-------LOGGER OUTPUT @ " + now + "-------------",
            "background: navy; color: #39FF14"
        );

        Array.from(arguments).map(function (m) {
            console.debug(m);
        });
    }
}

// Call 'c' function when the screen is ready to be shown.
// Until 'c' is called, creative will remain in loading state.
c();